// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'article.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$Article {
  int get pmid => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  List<String> get authors => throw _privateConstructorUsedError;
  String get journal => throw _privateConstructorUsedError;
  String get pubDate => throw _privateConstructorUsedError;
  String? get doi => throw _privateConstructorUsedError;
  String? get pmcid => throw _privateConstructorUsedError;
  String get abstract_ => throw _privateConstructorUsedError;
  String? get translatedTitle => throw _privateConstructorUsedError;
  String? get translatedAbstract => throw _privateConstructorUsedError;
  List<String> get meshTerms => throw _privateConstructorUsedError;
  bool get hasFullDetail => throw _privateConstructorUsedError;

  /// Create a copy of Article
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ArticleCopyWith<Article> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ArticleCopyWith<$Res> {
  factory $ArticleCopyWith(Article value, $Res Function(Article) then) =
      _$ArticleCopyWithImpl<$Res, Article>;
  @useResult
  $Res call({
    int pmid,
    String title,
    List<String> authors,
    String journal,
    String pubDate,
    String? doi,
    String? pmcid,
    String abstract_,
    String? translatedTitle,
    String? translatedAbstract,
    List<String> meshTerms,
    bool hasFullDetail,
  });
}

/// @nodoc
class _$ArticleCopyWithImpl<$Res, $Val extends Article>
    implements $ArticleCopyWith<$Res> {
  _$ArticleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Article
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pmid = null,
    Object? title = null,
    Object? authors = null,
    Object? journal = null,
    Object? pubDate = null,
    Object? doi = freezed,
    Object? pmcid = freezed,
    Object? abstract_ = null,
    Object? translatedTitle = freezed,
    Object? translatedAbstract = freezed,
    Object? meshTerms = null,
    Object? hasFullDetail = null,
  }) {
    return _then(
      _value.copyWith(
            pmid: null == pmid
                ? _value.pmid
                : pmid // ignore: cast_nullable_to_non_nullable
                      as int,
            title: null == title
                ? _value.title
                : title // ignore: cast_nullable_to_non_nullable
                      as String,
            authors: null == authors
                ? _value.authors
                : authors // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            journal: null == journal
                ? _value.journal
                : journal // ignore: cast_nullable_to_non_nullable
                      as String,
            pubDate: null == pubDate
                ? _value.pubDate
                : pubDate // ignore: cast_nullable_to_non_nullable
                      as String,
            doi: freezed == doi
                ? _value.doi
                : doi // ignore: cast_nullable_to_non_nullable
                      as String?,
            pmcid: freezed == pmcid
                ? _value.pmcid
                : pmcid // ignore: cast_nullable_to_non_nullable
                      as String?,
            abstract_: null == abstract_
                ? _value.abstract_
                : abstract_ // ignore: cast_nullable_to_non_nullable
                      as String,
            translatedTitle: freezed == translatedTitle
                ? _value.translatedTitle
                : translatedTitle // ignore: cast_nullable_to_non_nullable
                      as String?,
            translatedAbstract: freezed == translatedAbstract
                ? _value.translatedAbstract
                : translatedAbstract // ignore: cast_nullable_to_non_nullable
                      as String?,
            meshTerms: null == meshTerms
                ? _value.meshTerms
                : meshTerms // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            hasFullDetail: null == hasFullDetail
                ? _value.hasFullDetail
                : hasFullDetail // ignore: cast_nullable_to_non_nullable
                      as bool,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$ArticleImplCopyWith<$Res> implements $ArticleCopyWith<$Res> {
  factory _$$ArticleImplCopyWith(
    _$ArticleImpl value,
    $Res Function(_$ArticleImpl) then,
  ) = __$$ArticleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    int pmid,
    String title,
    List<String> authors,
    String journal,
    String pubDate,
    String? doi,
    String? pmcid,
    String abstract_,
    String? translatedTitle,
    String? translatedAbstract,
    List<String> meshTerms,
    bool hasFullDetail,
  });
}

/// @nodoc
class __$$ArticleImplCopyWithImpl<$Res>
    extends _$ArticleCopyWithImpl<$Res, _$ArticleImpl>
    implements _$$ArticleImplCopyWith<$Res> {
  __$$ArticleImplCopyWithImpl(
    _$ArticleImpl _value,
    $Res Function(_$ArticleImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of Article
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pmid = null,
    Object? title = null,
    Object? authors = null,
    Object? journal = null,
    Object? pubDate = null,
    Object? doi = freezed,
    Object? pmcid = freezed,
    Object? abstract_ = null,
    Object? translatedTitle = freezed,
    Object? translatedAbstract = freezed,
    Object? meshTerms = null,
    Object? hasFullDetail = null,
  }) {
    return _then(
      _$ArticleImpl(
        pmid: null == pmid
            ? _value.pmid
            : pmid // ignore: cast_nullable_to_non_nullable
                  as int,
        title: null == title
            ? _value.title
            : title // ignore: cast_nullable_to_non_nullable
                  as String,
        authors: null == authors
            ? _value._authors
            : authors // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        journal: null == journal
            ? _value.journal
            : journal // ignore: cast_nullable_to_non_nullable
                  as String,
        pubDate: null == pubDate
            ? _value.pubDate
            : pubDate // ignore: cast_nullable_to_non_nullable
                  as String,
        doi: freezed == doi
            ? _value.doi
            : doi // ignore: cast_nullable_to_non_nullable
                  as String?,
        pmcid: freezed == pmcid
            ? _value.pmcid
            : pmcid // ignore: cast_nullable_to_non_nullable
                  as String?,
        abstract_: null == abstract_
            ? _value.abstract_
            : abstract_ // ignore: cast_nullable_to_non_nullable
                  as String,
        translatedTitle: freezed == translatedTitle
            ? _value.translatedTitle
            : translatedTitle // ignore: cast_nullable_to_non_nullable
                  as String?,
        translatedAbstract: freezed == translatedAbstract
            ? _value.translatedAbstract
            : translatedAbstract // ignore: cast_nullable_to_non_nullable
                  as String?,
        meshTerms: null == meshTerms
            ? _value._meshTerms
            : meshTerms // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        hasFullDetail: null == hasFullDetail
            ? _value.hasFullDetail
            : hasFullDetail // ignore: cast_nullable_to_non_nullable
                  as bool,
      ),
    );
  }
}

/// @nodoc

class _$ArticleImpl implements _Article {
  const _$ArticleImpl({
    required this.pmid,
    required this.title,
    final List<String> authors = const [],
    this.journal = '',
    this.pubDate = '',
    this.doi,
    this.pmcid,
    this.abstract_ = '',
    this.translatedTitle,
    this.translatedAbstract,
    final List<String> meshTerms = const [],
    this.hasFullDetail = false,
  }) : _authors = authors,
       _meshTerms = meshTerms;

  @override
  final int pmid;
  @override
  final String title;
  final List<String> _authors;
  @override
  @JsonKey()
  List<String> get authors {
    if (_authors is EqualUnmodifiableListView) return _authors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_authors);
  }

  @override
  @JsonKey()
  final String journal;
  @override
  @JsonKey()
  final String pubDate;
  @override
  final String? doi;
  @override
  final String? pmcid;
  @override
  @JsonKey()
  final String abstract_;
  @override
  final String? translatedTitle;
  @override
  final String? translatedAbstract;
  final List<String> _meshTerms;
  @override
  @JsonKey()
  List<String> get meshTerms {
    if (_meshTerms is EqualUnmodifiableListView) return _meshTerms;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_meshTerms);
  }

  @override
  @JsonKey()
  final bool hasFullDetail;

  @override
  String toString() {
    return 'Article(pmid: $pmid, title: $title, authors: $authors, journal: $journal, pubDate: $pubDate, doi: $doi, pmcid: $pmcid, abstract_: $abstract_, translatedTitle: $translatedTitle, translatedAbstract: $translatedAbstract, meshTerms: $meshTerms, hasFullDetail: $hasFullDetail)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ArticleImpl &&
            (identical(other.pmid, pmid) || other.pmid == pmid) &&
            (identical(other.title, title) || other.title == title) &&
            const DeepCollectionEquality().equals(other._authors, _authors) &&
            (identical(other.journal, journal) || other.journal == journal) &&
            (identical(other.pubDate, pubDate) || other.pubDate == pubDate) &&
            (identical(other.doi, doi) || other.doi == doi) &&
            (identical(other.pmcid, pmcid) || other.pmcid == pmcid) &&
            (identical(other.abstract_, abstract_) ||
                other.abstract_ == abstract_) &&
            (identical(other.translatedTitle, translatedTitle) ||
                other.translatedTitle == translatedTitle) &&
            (identical(other.translatedAbstract, translatedAbstract) ||
                other.translatedAbstract == translatedAbstract) &&
            const DeepCollectionEquality().equals(
              other._meshTerms,
              _meshTerms,
            ) &&
            (identical(other.hasFullDetail, hasFullDetail) ||
                other.hasFullDetail == hasFullDetail));
  }

  @override
  int get hashCode => Object.hash(
    runtimeType,
    pmid,
    title,
    const DeepCollectionEquality().hash(_authors),
    journal,
    pubDate,
    doi,
    pmcid,
    abstract_,
    translatedTitle,
    translatedAbstract,
    const DeepCollectionEquality().hash(_meshTerms),
    hasFullDetail,
  );

  /// Create a copy of Article
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ArticleImplCopyWith<_$ArticleImpl> get copyWith =>
      __$$ArticleImplCopyWithImpl<_$ArticleImpl>(this, _$identity);
}

abstract class _Article implements Article {
  const factory _Article({
    required final int pmid,
    required final String title,
    final List<String> authors,
    final String journal,
    final String pubDate,
    final String? doi,
    final String? pmcid,
    final String abstract_,
    final String? translatedTitle,
    final String? translatedAbstract,
    final List<String> meshTerms,
    final bool hasFullDetail,
  }) = _$ArticleImpl;

  @override
  int get pmid;
  @override
  String get title;
  @override
  List<String> get authors;
  @override
  String get journal;
  @override
  String get pubDate;
  @override
  String? get doi;
  @override
  String? get pmcid;
  @override
  String get abstract_;
  @override
  String? get translatedTitle;
  @override
  String? get translatedAbstract;
  @override
  List<String> get meshTerms;
  @override
  bool get hasFullDetail;

  /// Create a copy of Article
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ArticleImplCopyWith<_$ArticleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
